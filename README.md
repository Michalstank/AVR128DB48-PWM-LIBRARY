# AVR128DB48-PWM-LIBRARY

**Version: 0.5.0**

**Program Memory Usage: 0.6%**  
**Data Memory Usage: 3.2%**  

This repository hosts Pulse Width Measurement Library for the card AVR128DB48. It is based on the PWM Library for the capstone project for NTNU Course IELET2111 - Microcontroller Systems. However this repository focuses on the continued developement of the library. 

# Documentation

Summary:

This is an Library for the card AVR128DB48 with main focus on the PWM Generation as well as Measurement. The Library was made in such a way that it would be easy to use for both new and advanced users. It mainly focuses on simplification of existing peripherals for both streamlined and quick way of setting them up. Entire library has been written in programming language C. 

## Which peripherals are covered

|Peripheral|Covered Functionality|
|----------|--------------------|
|`TCA0`|Dual Slope, Single Mode|
|`TCA1`|Dual Slope, Single Mode|
|`TCB0`|Pulse Width Measurement|
|`EVSYS`|Integration with TCB0 for PWM, Uses Channel 0|
|`PORTMUX`|Waveform Output setup for TCA0 & TCA1|

## How to use the Library

For the library to function download both of the PWM files and add them to the project you are working on. Therefore include the PWM.H file and configure the registers for desired results. Lastly call the `PWM_INIT()` function before the `while(1)` loop and `PWM_RUN()` at the start of the `while(1)` loop (**DO NOT USE OTHER FUNCTIONS FROM THE LIBRARY**)

## Example Initialization

An example of quick setup of TCA0 Timer for 25kHz output:

```
#include "PWM.h"

int main(void){
  PWM_CTRL.MAIN_CTRL = PWM_MASTER_ENABLE_bm | PWM_TCA0_ENABLE_bm | PWM_PORTMUX_OVERRIDE_bm;

  PWM_CTRL.CMP_CTRL = PWM_TCA0_CMP_0_bm;
  
  PWM_CTRL.TCA0_PERBUF_VAL = 0x50;
  
  PWM_CTRL.PWM_CMPBUF_DUTYCYCLE[0] = 0x50/2; //50% Duty Cycle
  
  PWM_INIT();
  
  while(1){
  
    PWM_RUN();
  
  }

return 0;
}
```

## Interrupt Handling

The library also includes the interrupts generated by the aforementioned peripherals. In order to change the behavior under those interrupts assign a new function to one of the function pointers, the fucntion assigned to the function pointer will then be executed under interrupt call. All of the function pointers expect the function to have return type as `void`. Interrupts are cleared automaticaly by the library. Below is the table for the interrupts and their respective function pointers.

|Peripheral|Interrupt|Function Pointer Name|
|----------|---------|----------------|
|`TCB0`    |CAPT - EVENT CAPTURE     |TCB0_CAPT_INT_fp|
|`TCB0`    |OVF - COUNTER OVERFLOW      |TCB0_OVF_INT_fp|
|`TCA0`|OVF - COUNTER OVERFLOW|TCA0_OVF_INT_fp|
|`TCA0`|CMP0 - COMPARE MATCH|TCA0_CMP0_INT_fp|
|`TCA0`|CMP1 - COMPARE MATCH|TCA0_CMP1_INT_fp|
|`TCA0`|CMP2 - COMPARE MATCH|TCA0_CMP2_INT_fp|

## "Register" Summary

All of the "registers" are part of the main library struct which can be referred to by PWM_CTRL. For view of the different registers use either the file attached below or refer to PWM.h file.

WIP - ADD LINK EXTERNAL FILE



